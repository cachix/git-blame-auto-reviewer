{"version":3,"file":"index.js","mappings":";AAAA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack/runtime/compat",".././lib/index.js"],"sourcesContent":["\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\\/\\/\\/\\w:/) ? 1 : 0, -1) + \"/\";","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core = __importStar(require(\"@actions/core\"));\nconst github = __importStar(require(\"@actions/github\"));\nconst github_api_1 = require(\"./github-api\");\nconst git_blame_1 = require(\"./git-blame\");\nasync function getInputs() {\n    return {\n        token: core.getInput(\"token\", { required: true }),\n        maxReviewers: parseInt(core.getInput(\"max-reviewers\") || \"3\"),\n        threshold: parseInt(core.getInput(\"threshold\") || \"20\"),\n        ignoreAuthors: core\n            .getInput(\"ignore-authors\")\n            .split(\",\")\n            .map((a) => a.trim())\n            .filter((a) => a.length > 0),\n        lookbackDays: parseInt(core.getInput(\"lookback-days\") || \"0\"),\n    };\n}\nasync function run() {\n    try {\n        const inputs = await getInputs();\n        const context = github.context;\n        // Only run on pull requests\n        if (!context.payload.pull_request) {\n            core.warning(\"This action only works on pull request events\");\n            return;\n        }\n        const pullRequest = context.payload.pull_request;\n        const prAuthor = pullRequest.user.login;\n        const octokit = github.getOctokit(inputs.token);\n        // Get changed files\n        core.info(\"ðŸ” Getting changed files...\");\n        const changedFiles = await (0, github_api_1.getChangedFiles)(octokit, context);\n        core.info(`ðŸ“ Found ${changedFiles.length} changed files`);\n        // Analyze blame for each file\n        core.info(\"ðŸ”¬ Analyzing git blame for changed lines...\");\n        const authorCommitMap = new Map();\n        const authorStatsMap = new Map();\n        for (const file of changedFiles) {\n            try {\n                const blameData = await (0, git_blame_1.analyzeFileBlame)(file, {\n                    baseRef: pullRequest.base.sha,\n                    headRef: pullRequest.head.sha,\n                    lookbackDays: inputs.lookbackDays,\n                });\n                // Aggregate stats by commit (we'll resolve to users later)\n                for (const [commit, lineCount] of blameData.entries()) {\n                    // Store commit -> author mapping for later resolution\n                    const author = `commit:${commit}`;\n                    if (!authorCommitMap.has(author)) {\n                        authorCommitMap.set(author, new Set());\n                    }\n                    authorCommitMap.get(author).add(commit);\n                    if (!authorStatsMap.has(author)) {\n                        authorStatsMap.set(author, {\n                            linesChanged: 0,\n                            filesAffected: 0,\n                            percentageOfChanges: 0,\n                            commits: new Set(),\n                        });\n                    }\n                    const stats = authorStatsMap.get(author);\n                    stats.linesChanged += lineCount;\n                    stats.filesAffected += 1;\n                    stats.commits.add(commit);\n                }\n            }\n            catch (error) {\n                const errorMessage = error instanceof Error ? error.message : String(error);\n                throw new Error(`Failed to analyze ${file.filename}: ${errorMessage}`);\n            }\n        }\n        // Resolve commits to GitHub users\n        core.info(\"ðŸ‘¤ Resolving commit authors to GitHub users...\");\n        const resolvedAuthors = new Map();\n        const unresolvedCommits = [];\n        for (const [authorKey, commits] of authorCommitMap.entries()) {\n            const stats = authorStatsMap.get(authorKey);\n            // Try to resolve using the first commit\n            const firstCommit = Array.from(commits)[0];\n            const githubUser = await (0, github_api_1.resolveCommitAuthor)(octokit, context, firstCommit);\n            if (githubUser) {\n                // Skip if it's the PR author\n                if (githubUser === prAuthor) {\n                    core.debug(`Skipping PR author: ${githubUser}`);\n                    continue;\n                }\n                // Skip if in ignore list\n                if (inputs.ignoreAuthors.includes(githubUser)) {\n                    core.debug(`Skipping ignored author: ${githubUser}`);\n                    continue;\n                }\n                // Merge stats if we already have this user\n                if (resolvedAuthors.has(githubUser)) {\n                    const existingStats = resolvedAuthors.get(githubUser);\n                    existingStats.linesChanged += stats.linesChanged;\n                    existingStats.filesAffected += stats.filesAffected;\n                    stats.commits.forEach((c) => existingStats.commits.add(c));\n                }\n                else {\n                    resolvedAuthors.set(githubUser, stats);\n                }\n                core.info(`âœ… Resolved ${commits.size} commits to @${githubUser}`);\n            }\n            else {\n                unresolvedCommits.push(...Array.from(commits));\n            }\n        }\n        if (unresolvedCommits.length > 0) {\n            core.warning(`âš ï¸  Could not resolve ${unresolvedCommits.length} commits to GitHub users`);\n        }\n        // Calculate percentages and filter reviewers\n        const totalLinesChanged = Array.from(resolvedAuthors.values()).reduce((sum, stats) => sum + stats.linesChanged, 0);\n        if (totalLinesChanged === 0) {\n            core.info(\"No lines changed by resolved authors\");\n            return;\n        }\n        const potentialReviewers = [];\n        for (const [username, stats] of resolvedAuthors.entries()) {\n            stats.percentageOfChanges =\n                (stats.linesChanged / totalLinesChanged) * 100;\n            if (stats.percentageOfChanges >= inputs.threshold) {\n                potentialReviewers.push({ username, stats });\n            }\n        }\n        // Sort by percentage of changes (descending)\n        potentialReviewers.sort((a, b) => b.stats.percentageOfChanges - a.stats.percentageOfChanges);\n        // Apply max reviewers limit\n        const reviewersToSuggest = potentialReviewers.slice(0, inputs.maxReviewers);\n        if (reviewersToSuggest.length === 0) {\n            core.info(\"ðŸ“­ No reviewers meet the threshold criteria\");\n            return;\n        }\n        // Create comment with review suggestions\n        core.info(`ðŸ“¬ Creating comment to suggest reviewers: ${reviewersToSuggest.map((r) => r.username).join(\", \")}`);\n        await (0, github_api_1.createReviewComment)(octokit, context, reviewersToSuggest.map((r) => ({\n            username: r.username,\n            percentage: r.stats.percentageOfChanges,\n            linesChanged: r.stats.linesChanged,\n        })));\n        // Output summary\n        core.info(\"\\nðŸ“Š Review Suggestion Summary:\");\n        reviewersToSuggest.forEach((reviewer) => {\n            core.info(`   ðŸ‘¤ @${reviewer.username}: ${reviewer.stats.percentageOfChanges.toFixed(1)}% ` +\n                `(${reviewer.stats.linesChanged} lines in ${reviewer.stats.filesAffected} files)`);\n        });\n        // Set outputs\n        core.setOutput(\"reviewers\", reviewersToSuggest.map((r) => r.username).join(\",\"));\n        core.setOutput(\"reviewer-count\", reviewersToSuggest.length.toString());\n    }\n    catch (error) {\n        core.setFailed(`Action failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n// Run the action\nrun();\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}